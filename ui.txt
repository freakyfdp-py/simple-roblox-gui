-- This is the complete, self-contained, image-free library code.
-- This version adds the Close (X) and Minimize (-) buttons to the header,
-- and implements the RightShift keybind to toggle the menu visibility.

-- Core Roblox Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TeleportService = game:GetService("TeleportService")
local TweenService = game:GetService("TweenService")

-- The main table to be returned as the module
local ExoUI = {}

-- Variables
local Player = Players.LocalPlayer
local ScreenGui = nil -- Now accessible globally in the module scope
local CurrentDraggableFrame = nil
local IsDragging = false
local DragOffset = nil -- Stores a Vector2

-- Configuration
local Config = {
    PrimaryColor = Color3.fromRGB(40, 44, 52),
    AccentColor = Color3.fromRGB(0, 150, 255),
    TextColor = Color3.fromRGB(255, 255, 255),
    HeaderHeight = 35,
    TabButtonHeight = 30,
    Padding = 10,
    SectionPadding = 8,
    ControlHeight = 25,
    Font = Enum.Font.Roboto,
    FontSize = Enum.FontSize.Size14,
    CornerRadius = UDim.new(0.05, 0)
}

-- Utility Functions
local function Create(ClassName, Properties)
    local instance = Instance.new(ClassName)
    for prop, value in pairs(Properties) do
        instance[prop] = value
    end
    return instance
end

-- =================================================================
-- UI Creation Functions
-- =================================================================

-- 1. Main UI and Drag Logic
function ExoUI:Init(Title)
    -- Destroy existing GUI if it exists
    if ScreenGui then ScreenGui:Destroy() end

    ScreenGui = Create("ScreenGui", {Name = "ExoUI_MainGui", ResetOnSpawn = false})
    ScreenGui.Parent = Player:WaitForChild("PlayerGui")

    local MainFrame = Create("Frame", {
        Name = "MainFrame",
        Size = UDim2.new(0, 400, 0, 500), -- Set an initial size
        Position = UDim2.new(0.5, -200, 0.5, -250), -- Centered
        BackgroundColor3 = Config.PrimaryColor,
        BorderSizePixel = 0,
        Parent = ScreenGui,
    })

    -- Add rounded corners
    Create("UICorner", {
        CornerRadius = UDim.new(0, 8),
        Parent = MainFrame
    })

    -- Header Frame for Title and Dragging
    local HeaderFrame = Create("Frame", {
        Name = "Header",
        Size = UDim2.new(1, 0, 0, Config.HeaderHeight),
        BackgroundColor3 = Config.AccentColor,
        BorderSizePixel = 0,
        Parent = MainFrame
    })

    -- Apply corner radius only to the top corners of the header (since it's inside MainFrame)
    Create("UICorner", {
        CornerRadius = UDim.new(0, 8),
        Parent = HeaderFrame
    })

    -- Control Buttons Container (to hold Close and Minimize)
    local ControlsContainer = Create("Frame", {
        Name = "ControlsContainer",
        Size = UDim2.new(0, 70, 1, 0), -- Enough width for two buttons + padding
        Position = UDim2.new(1, -70, 0, 0),
        BackgroundTransparency = 1,
        Parent = HeaderFrame
    })
    
    -- Horizontal List Layout for buttons
    Create("UIListLayout", {
        Name = "ControlsLayout",
        FillDirection = Enum.FillDirection.Horizontal,
        HorizontalAlignment = Enum.HorizontalAlignment.Right,
        VerticalAlignment = Enum.VerticalAlignment.Center,
        Padding = UDim.new(0, 5),
        Parent = ControlsContainer
    })
    
    -- Header Text (adjusted size to make space for control buttons)
    Create("TextLabel", {
        Name = "TitleLabel",
        Size = UDim2.new(1, -75, 1, 0), -- Adjusted width
        Position = UDim2.new(0, Config.Padding, 0, 0),
        Text = Title or "ExoUI",
        Font = Config.Font,
        TextSize = 18,
        TextColor3 = Config.TextColor,
        BackgroundTransparency = 1,
        Parent = HeaderFrame,
        TextXAlignment = Enum.TextXAlignment.Left
    })
    
    -- === 1. Minimize Button (-) ===
    local MinimizeButton = Create("TextButton", {
        Name = "MinimizeButton",
        Text = "â€”", -- En dash/Hyphen for minimize
        Size = UDim2.new(0, 30, 0, 25),
        BackgroundColor3 = Config.PrimaryColor,
        TextColor3 = Config.TextColor,
        Font = Config.Font,
        TextSize = 18,
        BorderSizePixel = 0,
        Parent = ControlsContainer,
    })
    
    Create("UICorner", {
        CornerRadius = UDim.new(0, 5),
        Parent = MinimizeButton
    })
    
    MinimizeButton.MouseButton1Click:Connect(function()
        -- Toggle the visibility of the MainFrame
        MainFrame.Visible = not MainFrame.Visible
        -- When minimized, the title bar remains visible (since it's part of the ScreenGui), 
        -- but since MainFrame holds the title bar, we just hide the MainFrame itself.
    end)
    
    -- === 2. Close/Rejoin Button (X) ===
    local CloseButton = Create("TextButton", {
        Name = "CloseButton",
        Text = "X",
        Size = UDim2.new(0, 30, 0, 25),
        BackgroundColor3 = Color3.fromRGB(200, 50, 50), -- Red color
        TextColor3 = Config.TextColor,
        Font = Config.Font,
        TextSize = 18,
        BorderSizePixel = 0,
        Parent = ControlsContainer,
    })
    
    Create("UICorner", {
        CornerRadius = UDim.new(0, 5),
        Parent = CloseButton
    })
    
    CloseButton.MouseButton1Click:Connect(function()
        -- 1. Destroy the entire ScreenGui artifact
        if ScreenGui then
            ScreenGui:Destroy()
        end
        
        -- 2. Attempt to rejoin the current game instance
        TeleportService:Teleport(game.PlaceId)
    end)

    -- === 3. Keybind Toggle (Right Shift) ===
    UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
        -- Ensure input is RightShift and not processed by core game scripts
        if input.KeyCode == Enum.KeyCode.RightShift and not gameProcessedEvent then
            -- Check if the main frame still exists before attempting to toggle
            if MainFrame and MainFrame.Parent then
                MainFrame.Visible = not MainFrame.Visible
            end
        end
    end)

    -- Dragging Logic
    local function StartDrag(input, gameProcessedEvent)
        if gameProcessedEvent then return end
        
        -- Only allow drag on MouseButton1 or Touch
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            IsDragging = true
            CurrentDraggableFrame = MainFrame
            
            -- FIX: InputObject.Position is Vector3. Convert to Vector2 for screen position math.
            local inputPosition = Vector2.new(input.Position.X, input.Position.Y) 
            
            DragOffset = inputPosition - MainFrame.Position.Offset
            
            -- Removed: input.Capture = true (due to error message)
        end
    end

    local function DoDrag(input)
        -- Check if we are dragging and the input type is a movement action
        if IsDragging and CurrentDraggableFrame and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            
            -- FIX: InputObject.Position is Vector3. Convert to Vector2.
            local inputPosition = Vector2.new(input.Position.X, input.Position.Y)
            
            local newPosition = inputPosition - DragOffset
            -- Set the frame's position using UDim2 with the calculated pixel offset
            CurrentDraggableFrame.Position = UDim2.new(0, newPosition.X, 0, newPosition.Y)
        end
    end

    local function EndDrag(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            IsDragging = false
            CurrentDraggableFrame = nil
            DragOffset = nil
        end
    end

    HeaderFrame.InputBegan:Connect(StartDrag)
    -- Connect to UserInputService.InputChanged so drag continues even outside the HeaderFrame bounds
    UserInputService.InputChanged:Connect(DoDrag)
    UserInputService.InputEnded:Connect(EndDrag)


    -- Layout for Tabs and Content
    local TabContainer = Create("Frame", {
        Name = "TabContainer",
        Size = UDim2.new(0.25, 0, 1, -Config.HeaderHeight),
        Position = UDim2.new(0, 0, 0, Config.HeaderHeight),
        BackgroundColor3 = Config.PrimaryColor,
        BorderSizePixel = 0,
        Parent = MainFrame
    })

    local ContentContainer = Create("Frame", {
        Name = "ContentContainer",
        Size = UDim2.new(0.75, 0, 1, -Config.HeaderHeight),
        Position = UDim2.new(0.25, 0, 0, Config.HeaderHeight),
        BackgroundColor3 = Config.PrimaryColor,
        BorderSizePixel = 0,
        Parent = MainFrame
    })

    -- UIListLayout for tabs
    Create("UIListLayout", {
        Name = "TabListLayout",
        Padding = UDim.new(0, 5),
        HorizontalAlignment = Enum.HorizontalAlignment.Center,
        VerticalAlignment = Enum.VerticalAlignment.Top,
        Parent = TabContainer,
        SortOrder = Enum.SortOrder.LayoutOrder
    })
    
    -- UIPadding for the content container
    Create("UIPadding", {
        PaddingTop = UDim.new(0, Config.Padding),
        PaddingBottom = UDim.new(0, Config.Padding),
        PaddingLeft = UDim.new(0, Config.Padding),
        PaddingRight = UDim.new(0, Config.Padding),
        Parent = ContentContainer
    })

    -- Add a property to the module to hold the main containers
    ExoUI.Containers = {
        MainFrame = MainFrame,
        TabContainer = TabContainer,
        ContentContainer = ContentContainer
    }
    
    ExoUI.Tabs = {}
    ExoUI.CurrentTabContent = nil
    
    return MainFrame
end

-- 2. Tab Creation
function ExoUI:CreateTab(Name, IsDefault)
    local tabContainer = ExoUI.Containers.TabContainer
    local contentContainer = ExoUI.Containers.ContentContainer
    
    -- Tab Button
    local TabButton = Create("TextButton", {
        Name = Name .. "TabButton",
        Text = Name,
        Size = UDim2.new(1, -10, 0, Config.TabButtonHeight),
        BackgroundColor3 = Config.PrimaryColor,
        TextColor3 = Config.TextColor,
        Font = Config.Font,
        TextSize = 16,
        BorderSizePixel = 0,
        Parent = tabContainer,
        LayoutOrder = #tabContainer:GetChildren()
    })
    
    -- Tab Content Frame
    local TabContent = Create("Frame", {
        Name = Name .. "TabContent",
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundTransparency = 1,
        BorderSizePixel = 0,
        Visible = IsDefault or false,
        Parent = contentContainer
    })

    -- UIListLayout for sections in content
    local ContentLayout = Create("UIListLayout", {
        Name = "ContentLayout",
        Padding = UDim.new(0, Config.Padding),
        HorizontalAlignment = Enum.HorizontalAlignment.Left,
        VerticalAlignment = Enum.VerticalAlignment.Top,
        FillDirection = Enum.FillDirection.Vertical,
        Parent = TabContent,
        SortOrder = Enum.SortOrder.LayoutOrder
    })

    -- Select Tab Logic
    local function SelectTab()
        -- Hide all other content frames
        for _, tab in pairs(ExoUI.Tabs) do
            tab.Content.Visible = false
            -- Reset button appearance
            tab.Button.BackgroundColor3 = Config.PrimaryColor
            
            -- Crucial: Close any open dropdowns when switching tabs
            -- This relies on the convention that dropdown options are parented to ScreenGui
            for _, child in ipairs(ScreenGui:GetChildren()) do
                if child.Name == "DropdownOptionsContainer" then
                    child:Destroy()
                end
            end
        end
        
        -- Show current content and highlight button
        TabContent.Visible = true
        TabButton.BackgroundColor3 = Config.AccentColor
        ExoUI.CurrentTabContent = TabContent
    end
    
    TabButton.MouseButton1Click:Connect(SelectTab)
    
    -- Set default tab
    if IsDefault then
        SelectTab()
    elseif not ExoUI.CurrentTabContent then
        -- If no default is set, set the first tab as visible
        TabContent.Visible = true
        TabButton.BackgroundColor3 = Config.AccentColor
        ExoUI.CurrentTabContent = TabContent
    end

    local tabTable = {
        Name = Name,
        Button = TabButton,
        Content = TabContent,
        Sections = {},
    }
    
    -- Add Section Creation Method to Tab Table
    function tabTable:section(sectionName, layoutOrder)
        local SectionFrame = Create("Frame", {
            Name = sectionName:gsub("%s+", "_") .. "Section",
            Size = UDim2.new(1, 0, 0, 0), -- Size will be determined by its children
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            Parent = TabContent,
            LayoutOrder = layoutOrder or #TabContent:GetChildren()
        })

        -- Section Title
        local TitleLabel = Create("TextLabel", {
            Name = "SectionTitle",
            Text = sectionName,
            Size = UDim2.new(1, 0, 0, 20),
            Position = UDim2.new(0, 0, 0, 0),
            Font = Config.Font,
            TextSize = 15,
            TextColor3 = Config.AccentColor,
            BackgroundTransparency = 1,
            TextXAlignment = Enum.TextXAlignment.Left,
            Parent = SectionFrame
        })
        
        -- Control Container
        local Controls = Create("Frame", {
            Name = "ControlsContainer",
            Size = UDim2.new(1, 0, 1, -TitleLabel.Size.Y.Offset),
            Position = UDim2.new(0, 0, 0, TitleLabel.Size.Y.Offset),
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            Parent = SectionFrame
        })

        local ControlsLayout = Create("UIListLayout", {
            Name = "ControlsLayout",
            Padding = UDim.new(0, Config.SectionPadding),
            HorizontalAlignment = Enum.HorizontalAlignment.Left,
            VerticalAlignment = Enum.VerticalAlignment.Top,
            FillDirection = Enum.FillDirection.Vertical,
            Parent = Controls,
            SortOrder = Enum.SortOrder.LayoutOrder
        })
        
        -- Automatic sizing based on content
        -- This property change listener is the robust way to auto-resize
        ControlsLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
            SectionFrame.Size = UDim2.new(1, 0, 0, ControlsLayout.AbsoluteContentSize.Y + TitleLabel.Size.Y.Offset)
        end)
        
        -- Initial size update
        SectionFrame.Size = UDim2.new(1, 0, 0, ControlsLayout.AbsoluteContentSize.Y + TitleLabel.Size.Y.Offset)


        local sectionTable = {
            Name = sectionName,
            Frame = SectionFrame,
            Controls = Controls,
            ControlsLayout = ControlsLayout
        }

        -- Add Control Creation Methods
        function sectionTable:checkbox(controlName, defaultValue, callback)
            return ExoUI.Controls:_CreateCheckbox(self.Controls, controlName, defaultValue, callback)
        end
        function sectionTable:slider(controlName, min, max, defaultValue, increment, callback)
            return ExoUI.Controls:_CreateSlider(self.Controls, controlName, min, max, defaultValue, increment, callback)
        end
        function sectionTable:dropdown(controlName, options, defaultValue, callback)
            return ExoUI.Controls:_CreateDropdown(self.Controls, controlName, options, defaultValue, callback)
        end
        function sectionTable:textbox(controlName, placeholder, defaultValue, callback)
            return ExoUI.Controls:_CreateTextbox(self.Controls, controlName, placeholder, defaultValue, callback)
        end
        
        -- Store section
        table.insert(tabTable.Sections, sectionTable)
        return sectionTable
    end
    
    ExoUI.Tabs[Name] = tabTable
    return tabTable
end

-- =================================================================
-- Control Creation Methods
-- =================================================================
ExoUI.Controls = {}

-- 3. Checkbox
function ExoUI.Controls:_CreateCheckbox(ParentFrame, controlName, defaultValue, callback)
    
    local ControlFrame = Create("Frame", {
        Name = controlName:gsub("%s+", "_") .. "Control",
        Size = UDim2.new(1, 0, 0, Config.ControlHeight),
        BackgroundTransparency = 1,
        BorderSizePixel = 0,
        Parent = ParentFrame
    })
    
    -- Label
    Create("TextLabel", {
        Name = "Label",
        Text = controlName,
        Size = UDim2.new(1, -(Config.ControlHeight + Config.Padding), 1, 0),
        Position = UDim2.new(0, 0, 0, 0),
        Font = Config.Font,
        TextSize = 14,
        TextColor3 = Config.TextColor,
        BackgroundTransparency = 1,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = ControlFrame
    })
    
    local currentState = defaultValue
    
    -- Checkbox Button
    local CheckButton = Create("TextButton", {
        Name = "CheckButton",
        Text = "",
        Size = UDim2.new(0, Config.ControlHeight, 0, Config.ControlHeight),
        Position = UDim2.new(1, -Config.ControlHeight, 0, 0),
        BackgroundColor3 = Config.PrimaryColor,
        BorderSizePixel = 0,
        Parent = ControlFrame
    })
    
    Create("UICorner", {
        CornerRadius = UDim.new(0, 5),
        Parent = CheckButton
    })
    
    -- Checkmark visual (using a Frame, no images)
    local Checkmark = Create("Frame", {
        Name = "Checkmark",
        Size = UDim2.new(0.6, 0, 0.6, 0),
        Position = UDim2.new(0.5, 0, 0.5, 0),
        AnchorPoint = Vector2.new(0.5, 0.5),
        BackgroundColor3 = Config.AccentColor,
        BorderSizePixel = 0,
        Visible = currentState,
        Parent = CheckButton
    })

    Create("UICorner", {
        CornerRadius = UDim.new(0, 3),
        Parent = Checkmark
    })

    local function updateVisuals()
        Checkmark.Visible = currentState
        pcall(callback, currentState)
    end
    
    local function onClick()
        currentState = not currentState
        updateVisuals()
    end
    
    CheckButton.MouseButton1Click:Connect(onClick)
    
    -- Initial callback
    pcall(callback, currentState)
    
    return ControlFrame
end

-- 4. Slider
function ExoUI.Controls:_CreateSlider(ParentFrame, controlName, min, max, defaultValue, increment, callback)

    local ControlFrame = Create("Frame", {
        Name = controlName:gsub("%s+", "_") .. "Control",
        Size = UDim2.new(1, 0, 0, Config.ControlHeight * 2),
        BackgroundTransparency = 1,
        BorderSizePixel = 0,
        Parent = ParentFrame
    })
    
    local currentValue = defaultValue
    
    -- Label and Value Display
    local LabelValueFrame = Create("Frame", {
        Name = "LabelValueFrame",
        Size = UDim2.new(1, 0, 0, Config.ControlHeight),
        BackgroundTransparency = 1,
        Parent = ControlFrame
    })

    Create("TextLabel", {
        Name = "Label",
        Text = controlName,
        Size = UDim2.new(0.7, 0, 1, 0),
        Position = UDim2.new(0, 0, 0, 0),
        Font = Config.Font,
        TextSize = 14,
        TextColor3 = Config.TextColor,
        BackgroundTransparency = 1,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = LabelValueFrame
    })

    local ValueLabel = Create("TextLabel", {
        Name = "Value",
        Text = string.format("%.1f", currentValue),
        Size = UDim2.new(0.3, 0, 1, 0),
        Position = UDim2.new(0.7, 0, 0, 0),
        Font = Config.Font,
        TextSize = 14,
        TextColor3 = Config.AccentColor,
        BackgroundTransparency = 1,
        TextXAlignment = Enum.TextXAlignment.Right,
        Parent = LabelValueFrame
    })
    
    -- Slider Background
    local SliderFrame = Create("Frame", {
        Name = "SliderFrame",
        Size = UDim2.new(1, 0, 0, Config.ControlHeight),
        Position = UDim2.new(0, 0, 0, Config.ControlHeight),
        BackgroundTransparency = 1,
        Parent = ControlFrame
    })
    
    local BackgroundBar = Create("Frame", {
        Name = "BackgroundBar",
        Size = UDim2.new(1, 0, 0, 4),
        Position = UDim2.new(0, 0, 0.5, -2),
        BackgroundColor3 = Config.PrimaryColor,
        BorderSizePixel = 0,
        Parent = SliderFrame
    })
    
    Create("UICorner", {
        CornerRadius = UDim.new(0, 2),
        Parent = BackgroundBar
    })
    
    -- Fill Bar
    local FillBar = Create("Frame", {
        Name = "FillBar",
        Size = UDim2.new((currentValue - min) / (max - min), 0, 1, 0),
        BackgroundColor3 = Config.AccentColor,
        BorderSizePixel = 0,
        Parent = BackgroundBar
    })
    
    -- Thumb Handle
    local Thumb = Create("Frame", {
        Name = "Thumb",
        Size = UDim2.new(0, 12, 0, 12),
        Position = UDim2.new((currentValue - min) / (max - min), 0, 0.5, -6),
        AnchorPoint = Vector2.new(0.5, 0.5),
        BackgroundColor3 = Config.TextColor,
        BorderSizePixel = 0,
        Parent = SliderFrame
    })
    
    Create("UICorner", {
        CornerRadius = UDim.new(0, 6),
        Parent = Thumb
    })

    -- Dragging Logic
    local IsDraggingSlider = false

    local function updateValue(inputPos)
        local barWidth = BackgroundBar.AbsoluteSize.X
        local barX = BackgroundBar.AbsolutePosition.X
        local relativeX = math.clamp(inputPos.X - barX, 0, barWidth)
        local percentage = relativeX / barWidth
        
        local rawValue = min + (max - min) * percentage
        
        -- Apply increment/step
        if increment > 0 then
            rawValue = math.floor(rawValue / increment + 0.5) * increment
        end
        
        currentValue = math.clamp(rawValue, min, max)
        
        -- Update UI
        local newScale = (currentValue - min) / (max - min)
        FillBar.Size = UDim2.new(newScale, 0, 1, 0)
        Thumb.Position = UDim2.new(newScale, 0, 0.5, -6)
        ValueLabel.Text = string.format("%.1f", currentValue)
        
        pcall(callback, currentValue)
    end

    local function StartDragSlider(input, gameProcessedEvent)
        if gameProcessedEvent then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            IsDraggingSlider = true
            -- FIX: InputObject.Position is Vector3. Convert to Vector2 for screen position math.
            local inputPosition = Vector2.new(input.Position.X, input.Position.Y)
            updateValue(inputPosition)
        end
    end
    
    local function DoDragSlider(input)
        if IsDraggingSlider and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            -- FIX: InputObject.Position is Vector3. Convert to Vector2.
            local inputPosition = Vector2.new(input.Position.X, input.Position.Y)
            updateValue(inputPosition)
        end
    end

    local function EndDragSlider(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            IsDraggingSlider = false
        end
    end

    -- Connect to InputBegan on the draggable surfaces
    Thumb.InputBegan:Connect(StartDragSlider)
    BackgroundBar.InputBegan:Connect(StartDragSlider)
    
    -- Connect to global input events for continuous dragging
    UserInputService.InputChanged:Connect(DoDragSlider)
    UserInputService.InputEnded:Connect(EndDragSlider)
    
    -- Initial callback
    pcall(callback, currentValue)

    return ControlFrame
end

-- 5. Dropdown
function ExoUI.Controls:_CreateDropdown(ParentFrame, controlName, options, defaultValue, callback)
    
    local ControlFrame = Create("Frame", {
        Name = controlName:gsub("%s+", "_") .. "Control",
        Size = UDim2.new(1, 0, 0, Config.ControlHeight),
        BackgroundTransparency = 1,
        BorderSizePixel = 0,
        Parent = ParentFrame
    })
    
    -- Label
    Create("TextLabel", {
        Name = "Label",
        Text = controlName,
        Size = UDim2.new(0.5, 0, 1, 0),
        Position = UDim2.new(0, 0, 0, 0),
        Font = Config.Font,
        TextSize = 14,
        TextColor3 = Config.TextColor,
        BackgroundTransparency = 1,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = ControlFrame
    })
    
    local currentState = defaultValue
    local OptionsContainer = nil -- Initialize here
    
    -- Dropdown Button
    local DropdownButton = Create("TextButton", {
        Name = "DropdownButton",
        Text = defaultValue,
        Size = UDim2.new(0.45, 0, 1, 0),
        Position = UDim2.new(0.55, 0, 0, 0),
        BackgroundColor3 = Config.PrimaryColor,
        TextColor3 = Config.TextColor,
        Font = Config.Font,
        TextSize = 14,
        BorderSizePixel = 0,
        Parent = ControlFrame
    })
    
    Create("UICorner", {
        CornerRadius = UDim.new(0, 5),
        Parent = DropdownButton
    })
    
    -- Options Container setup function
    local function createOptionsContainer()
        -- Use a unique name to easily find and destroy later
        OptionsContainer = Create("Frame", {
            Name = "DropdownOptionsContainer",
            -- Size will be set dynamically on open
            Size = UDim2.new(0, 0, 0, 0), 
            Position = UDim2.new(0, 0, 0, 0),
            AnchorPoint = Vector2.new(0, 0),
            BackgroundColor3 = Config.PrimaryColor,
            BorderSizePixel = 0,
            Visible = false,
            ZIndex = 5, -- High ZIndex to ensure it is on top
            Parent = ScreenGui -- <-- **FIX: Parented to ScreenGui for overlay**
        })
        
        Create("UICorner", {
            CornerRadius = UDim.new(0, 5),
            Parent = OptionsContainer
        })
        
        local OptionsLayout = Create("UIListLayout", {
            Name = "OptionsLayout",
            Padding = UDim.new(0, 1),
            FillDirection = Enum.FillDirection.Vertical,
            Parent = OptionsContainer,
            SortOrder = Enum.SortOrder.LayoutOrder
        })
        
        -- Function to handle option selection
        local function selectOption(option)
            currentState = option
            DropdownButton.Text = option
            OptionsContainer.Visible = false
            pcall(callback, option)
        end
        
        -- Populate Options
        for i, option in ipairs(options) do
            local OptionButton = Create("TextButton", {
                Name = option:gsub("%s+", "_") .. "Option",
                Text = option,
                Size = UDim2.new(1, 0, 0, Config.ControlHeight),
                BackgroundColor3 = Config.PrimaryColor,
                TextColor3 = Config.TextColor,
                Font = Config.Font,
                TextSize = 14,
                BorderSizePixel = 0,
                Parent = OptionsContainer
            })
            
            -- Highlight on hover/selection
            OptionButton.MouseEnter:Connect(function() OptionButton.BackgroundColor3 = Config.AccentColor end)
            OptionButton.MouseLeave:Connect(function() OptionButton.BackgroundColor3 = Config.PrimaryColor end)
            
            OptionButton.MouseButton1Click:Connect(function()
                selectOption(option)
            end)
        end
        
        -- Wait for the UIListLayout to calculate its size, then update container height
        OptionsLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
            OptionsContainer.Size = UDim2.new(0, DropdownButton.AbsoluteSize.X, 0, OptionsLayout.AbsoluteContentSize.Y)
        end)
        
        -- Destroy the detached container if the control is removed
        ControlFrame.AncestryChanged:Connect(function()
            if not ControlFrame.Parent then
                OptionsContainer:Destroy()
            end
        end)

        return OptionsLayout
    end
    
    -- Create the container and get the layout for size monitoring
    local OptionsLayout = createOptionsContainer()


    -- Toggle Dropdown
    local function toggleDropdown()
        
        -- If another dropdown is open, close it first
        for _, child in ipairs(ScreenGui:GetChildren()) do
            if child.Name == "DropdownOptionsContainer" and child ~= OptionsContainer then
                child.Visible = false
            end
        end

        OptionsContainer.Visible = not OptionsContainer.Visible
        
        if OptionsContainer.Visible then
            -- Calculate absolute position and size of the button
            local absPos = DropdownButton.AbsolutePosition
            local absSize = DropdownButton.AbsoluteSize
            
            -- Set the width and height based on the button and content
            OptionsContainer.Size = UDim2.new(0, absSize.X, 0, OptionsLayout.AbsoluteContentSize.Y)
            
            -- Position the container just below the button
            OptionsContainer.Position = UDim2.new(0, absPos.X, 0, absPos.Y + absSize.Y + 1) -- +1 for a small gap
        end
    end
    
    -- Close the dropdown if the user clicks anywhere else
    local closeConnection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
        if not gameProcessedEvent and OptionsContainer.Visible then
            local mousePos = Vector2.new(input.Position.X, input.Position.Y)
            -- Check if the click is outside the button and the options container
            local isOverButton = DropdownButton:GetAbsolutePosition().X <= mousePos.X and mousePos.X <= DropdownButton:GetAbsolutePosition().X + DropdownButton.AbsoluteSize.X and
                                 DropdownButton:GetAbsolutePosition().Y <= mousePos.Y and mousePos.Y <= DropdownButton:GetAbsolutePosition().Y + DropdownButton.AbsoluteSize.Y
            
            local isOverOptions = OptionsContainer:GetAbsolutePosition().X <= mousePos.X and mousePos.X <= OptionsContainer:GetAbsolutePosition().X + OptionsContainer.AbsoluteSize.X and
                                  OptionsContainer:GetAbsolutePosition().Y <= mousePos.Y and mousePos.Y <= OptionsContainer:GetAbsolutePosition().Y + OptionsContainer.AbsoluteSize.Y

            if not isOverButton and not isOverOptions then
                OptionsContainer.Visible = false
            end
        end
    end)
    
    DropdownButton.MouseButton1Click:Connect(toggleDropdown)
    
    -- Initial callback
    pcall(callback, currentState)
    
    return ControlFrame
end

-- 6. Textbox
function ExoUI.Controls:_CreateTextbox(ParentFrame, controlName, placeholder, defaultValue, callback)

    local ControlFrame = Create("Frame", {
        Name = controlName:gsub("%s+", "_") .. "Control",
        Size = UDim2.new(1, 0, 0, Config.ControlHeight),
        BackgroundTransparency = 1,
        BorderSizePixel = 0,
        Parent = ParentFrame
    })

    -- Label
    Create("TextLabel", {
        Name = "Label",
        Text = controlName,
        Size = UDim2.new(0.5, 0, 1, 0),
        Position = UDim2.new(0, 0, 0, 0),
        Font = Config.Font,
        TextSize = 14,
        TextColor3 = Config.TextColor,
        BackgroundTransparency = 1,
        TextXAlignment = Enum.TextXAlignment.Left,
        Parent = ControlFrame
    })

    -- Textbox
    local TextBox = Create("TextBox", {
        Name = "TextBox",
        Size = UDim2.new(0.45, 0, 1, 0),
        Position = UDim2.new(0.55, 0, 0, 0),
        BackgroundColor3 = Config.PrimaryColor,
        TextColor3 = Config.TextColor,
        Font = Config.Font,
        TextSize = 14,
        Text = defaultValue or "",
        PlaceholderText = placeholder or "Enter value...",
        PlaceholderColor3 = Config.TextColor:lerp(Config.PrimaryColor, 0.5),
        ClearTextOnFocus = false,
        TextXAlignment = Enum.TextXAlignment.Left,
        BorderSizePixel = 0,
        Parent = ControlFrame
    })
    
    Create("UICorner", {
        CornerRadius = UDim.new(0, 5),
        Parent = TextBox
    })

    -- Change handling
    local function onTextChange()
        pcall(callback, TextBox.Text)
    end
    
    -- Use FocusLost to commit the text, especially when enter is pressed
    TextBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            onTextChange()
        end
    end)
    
    -- Also use TextChanged for real-time updates if needed, but FocusLost is usually better
    TextBox.Changed:Connect(function(property)
        if property == "Text" then
            onTextChange()
        end
    end)


    -- Initial callback
    pcall(callback, defaultValue or "")

    return ControlFrame
end

-- Return the main module table
return ExoUI
